{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTP Core Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Provides both sync and async interfaces. Supports HTTP/1.1 and HTTP/2. Async backend support for asyncio and trio . Automatic connection pooling. HTTP(S) proxy support. Quickstart Here's an example of making an HTTP GET request using httpcore ... async with httpcore . AsyncConnectionPool () as http : http_version , status_code , reason_phrase , headers , stream = await http . request ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 433 , b '/' ), headers = [( b 'host' : b 'example.org' ), ( b 'user-agent' : 'httpcore' )] ) try : body = b '' . join ( chunk async for chunk in stream ) finally : await stream . close () print ( status_code , body ) Motivation You probably don't want to be using HTTP Core directly. It might make sense if you're writing something like a proxy service in Python, and you just want something at the lowest possible level, but more typically you'll want to use a higher level client library, such as httpx . The motivation for httpcore is: To provide a reusable low-level client library, that other packages can then build on top of. To provide a really clear interface split between the networking code and client logic, so that each is easier to understand and reason about in isolation.","title":"Introduction"},{"location":"#http-core","text":"Do one thing, and do it well. The HTTP Core package provides a minimal low-level HTTP client, which does one thing only. Sending HTTP requests. It does not provide any high level model abstractions over the API, does not handle redirects, multipart uploads, building authentication headers, transparent HTTP caching, URL parsing, session cookie handling, content or charset decoding, handling JSON, environment based configuration defaults, or any of that Jazz. Some things HTTP Core does do: Sending HTTP requests. Provides both sync and async interfaces. Supports HTTP/1.1 and HTTP/2. Async backend support for asyncio and trio . Automatic connection pooling. HTTP(S) proxy support.","title":"HTTP Core"},{"location":"#quickstart","text":"Here's an example of making an HTTP GET request using httpcore ... async with httpcore . AsyncConnectionPool () as http : http_version , status_code , reason_phrase , headers , stream = await http . request ( method = b 'GET' , url = ( b 'https' , b 'example.org' , 433 , b '/' ), headers = [( b 'host' : b 'example.org' ), ( b 'user-agent' : 'httpcore' )] ) try : body = b '' . join ( chunk async for chunk in stream ) finally : await stream . close () print ( status_code , body )","title":"Quickstart"},{"location":"#motivation","text":"You probably don't want to be using HTTP Core directly. It might make sense if you're writing something like a proxy service in Python, and you just want something at the lowest possible level, but more typically you'll want to use a higher level client library, such as httpx . The motivation for httpcore is: To provide a reusable low-level client library, that other packages can then build on top of. To provide a really clear interface split between the networking code and client logic, so that each is easier to understand and reason about in isolation.","title":"Motivation"},{"location":"api/","text":"Developer Interface Async API Overview The AsyncHTTPTransport and AsyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. AsyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , timeout=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, int, bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[AsyncByteStream] - The body of the HTTP request. timeout - Optional[Dict[str, Optional[float]]] - A dictionary of timeout values for I/O operations. Returns: A five-tuple of: http_version - bytes - The HTTP version used by the server, such as b'HTTP/1.1' . status_code - int - The HTTP status code, such as 200 . reason_phrase - bytes - Any HTTP reason phrase, such as b'OK' . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - AsyncByteStream - The body of the HTTP response. aclose ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. AsyncByteStream ( iterator=None , close_func=None ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __aiter__ method, and optionally the close method. aiter ( self ) Yield bytes representing the request or response body. aclose ( self ) Must be called by the client to indicate that the stream has been closed. The AsyncConnectionPool class is a concrete implementation of AsyncHTTPTransport . class httpcore. AsyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive=None , keepalive_expiry=None , http2=False ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support. Sync API Overview The SyncHTTPTransport and SyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. SyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , timeout=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, int, bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[SyncByteStream] - The body of the HTTP request. timeout - Optional[Dict[str, Optional[float]]] - A dictionary of timeout values for I/O operations. Returns: A five-tuple of: http_version - bytes - The HTTP version used by the server, such as b'HTTP/1.1' . status_code - int - The HTTP status code, such as 200 . reason_phrase - bytes - Any HTTP reason phrase, such as b'OK' . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - SyncByteStream - The body of the HTTP response. close ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. SyncByteStream ( iterator=None , close_func=None ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __iter__ method, and optionally the close method. iter ( self ) Yield bytes representing the request or response body. close ( self ) Must be called by the client to indicate that the stream has been closed. The SyncConnectionPool class is a concrete implementation of SyncHTTPTransport . class httpcore. SyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive=None , keepalive_expiry=None , http2=False ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support.","title":"Developer Interface"},{"location":"api/#developer-interface","text":"","title":"Developer Interface"},{"location":"api/#async-api-overview","text":"The AsyncHTTPTransport and AsyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. AsyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , timeout=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, int, bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[AsyncByteStream] - The body of the HTTP request. timeout - Optional[Dict[str, Optional[float]]] - A dictionary of timeout values for I/O operations. Returns: A five-tuple of: http_version - bytes - The HTTP version used by the server, such as b'HTTP/1.1' . status_code - int - The HTTP status code, such as 200 . reason_phrase - bytes - Any HTTP reason phrase, such as b'OK' . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - AsyncByteStream - The body of the HTTP response. aclose ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. AsyncByteStream ( iterator=None , close_func=None ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __aiter__ method, and optionally the close method. aiter ( self ) Yield bytes representing the request or response body. aclose ( self ) Must be called by the client to indicate that the stream has been closed. The AsyncConnectionPool class is a concrete implementation of AsyncHTTPTransport . class httpcore. AsyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive=None , keepalive_expiry=None , http2=False ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support.","title":"Async API Overview"},{"location":"api/#sync-api-overview","text":"The SyncHTTPTransport and SyncByteStream classes provide the base interface which transport classes need to implement. class httpcore. SyncHTTPTransport ( ) The base interface for sending HTTP requests. Concete implementations should subclass this class, and implement the request method, and optionally the close method. request ( self , method , url , headers=None , stream=None , timeout=None ) The interface for sending a single HTTP request, and returning a response. Parameters: method - bytes - The HTTP method, such as b'GET' . url - Tuple[bytes, bytes, int, bytes] - The URL as a 4-tuple of (scheme, host, port, path). headers - Optional[List[Tuple[bytes, bytes]]] - Any HTTP headers to send with the request. stream - Optional[SyncByteStream] - The body of the HTTP request. timeout - Optional[Dict[str, Optional[float]]] - A dictionary of timeout values for I/O operations. Returns: A five-tuple of: http_version - bytes - The HTTP version used by the server, such as b'HTTP/1.1' . status_code - int - The HTTP status code, such as 200 . reason_phrase - bytes - Any HTTP reason phrase, such as b'OK' . headers - List[Tuple[bytes, bytes]] - Any HTTP headers included on the response. stream - SyncByteStream - The body of the HTTP response. close ( self ) Close the implementation, which should close any outstanding response streams, and any keep alive connections. class httpcore. SyncByteStream ( iterator=None , close_func=None ) The base interface for request and response bodies. Concrete implementations should subclass this class, and implement the __iter__ method, and optionally the close method. iter ( self ) Yield bytes representing the request or response body. close ( self ) Must be called by the client to indicate that the stream has been closed. The SyncConnectionPool class is a concrete implementation of SyncHTTPTransport . class httpcore. SyncConnectionPool ( ssl_context=None , max_connections=None , max_keepalive=None , keepalive_expiry=None , http2=False ) A connection pool for making HTTP requests. Parameters: ssl_context - Optional[SSLContext] - An SSL context to use for verifying connections. max_connections - Optional[int] - The maximum number of concurrent connections to allow. max_keepalive - Optional[int] - The maximum number of connections to allow before closing keep-alive connections. keepalive_expiry - Optional[float] - The maximum time to allow before closing a keep-alive connection. http2 - bool - Enable HTTP/2 support.","title":"Sync API Overview"}]}